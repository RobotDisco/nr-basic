# Lambda permission
# cloudwatch event cron
# Lambda
Resources:
  Role:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
              - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns: 
        - "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  ScheduledRule: 
    Type: AWS::Events::Rule
    Properties: 
      Description: "NRBasic"
      ScheduleExpression: "rate(1 minute)"
      State: "ENABLED"
      Targets: 
        - Arn: !GetAtt LambdaFunction.Arn
          Id: "NRBasicLambda"
  PermissionForEventsToInvokeLambda: 
    Type: AWS::Lambda::Permission
    Properties: 
      FunctionName: !Ref LambdaFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt ScheduledRule.Arn
  LambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt Role.Arn
      Code:
        ZipFile: |
          from botocore.vendored import requests
          import os
          import time

          def handler(event,context):
              # For cookies and error handling
              session = requests.Session()
              session.hooks = {
              'response': lambda r, *args, **kwargs: r.raise_for_status()
              }


              #  Login
              # irritating hack because of SSL
              login_cookies = dict(login_service_login_newrelic_com_tokens="%7B%22token%22%3A+%22LR8u3n%2FFt9cTigQg9tSgZPBv0L96ObinWQV%2FbRYGVleP7AQa215VrUNwJmTWOYtHRdXcntotoIah11cvbtfpD%2Bc%2BmJ4mp74vlMhI6LqAKzgQgEyCW03fhonF4AqTocbEo3V%2B1m8AqxzmxdAFlhKDV4pHFsutJbIXU5%2Fw1ISmgD%2BmpTEwFJZgAIRuIVlCbJpSttwdlrrNc0KcEU1s1KyVM3h8%2F28f64EKdI%2BgN6jIslyq9uHb3%2BVSBISkZW75CfFuqPRbDm8845T5ueL0RE5Zy4HrbUG4Iv5tXVRdP6K2qQDlxOkUM%2FXOZkxQMDRdYGJjg1O%2FOCN55wpMh59Pr%2BO7HA%3D%3D%22%2C+%22refresh_token%22%3A+%22IPsewoLmZNkGAcPAZE996feSgu%2FOz2Lg4RQ5ubSImPyHoZNy59ooy1leuOI3kZXym9uERkB3O0IegCQWCe%2BLuQ24VIvLqo7H32xcjuSFkrITbnhxITnI5SlfL32YdkGuy3hl8H%2BBX6cPGlHMxzAfEI8YDRTdWwQt%2BocE19A9yvpOupoFOXXkT0n9CoGSjymdWYlo8NH2frZvJJaaEjVKBOrhotAzIR2dR7Zn5IsPTZYE%2F7lQ2eMtu5JFwuo7isPYImNmLYO3BRHHJov8%2Fe2IoMQsCFNpr%2Bzo5VctTR6pUDCvAppRkInoFxVo3QnJCXksozvEotNuLzNm96lAxb04og%3D%3D%22%7D")
              #login_response = session.post("https://login.newrelic.com/login", cookies=login_cookies)
              
              custom_headers = {
                  "X-Requested-With": "XMLHttpRequest",
                  "Accept": "application/json"
              }

              # Get users
              users_response = session.get(f"https://user-management.service.newrelic.com/accounts/{os.getenv('ACCOUNT_ID')}/users",  headers=custom_headers, cookies=login_cookies)
              
              # Determine which users need to be switched back to basic
              switch_to_basic = []
              for user in users_response.json():
                  roles = [role['id'] for role in user['roles'] ]
                  if int(os.getenv("ROLE_ID")) in roles: # check if in the auto role
                      if user['user_tier_id'] == 0: #check if full role
                          if user['last_access_at'] + int(os.getenv("TIMEOUT")) < time.time(): # check if the last access + timeout is less than the current timestamp
                              switch_to_basic.append(user['user_id'])

              custom_headers['Content-Type'] = 'application/json'
                              
              # Update accounts
              for user_id in switch_to_basic:
                  print(f"Switching {str(user_id)} back to basic")
                  update_response = requests.Session().put(f"https://rpm.newrelic.com/user_management/accounts/{os.getenv('ACCOUNT_ID')}/users/{user['user_id']}",
                    headers=custom_headers,
                    cookies=login_cookies,
                    json = {
                      'account_view': {
                        'user_tier_id': 1
                      }
                    }  
                  )

                  print(update_response)
          if __name__ == "__main__":
              handler({},{})
      Environment:
        Variables: 
          TIMEOUT: !Ref Timeout
          ACCOUNT_ID: !Ref AccountID
          ROLE_ID: !Ref RoleID
          USERNAME: !Ref NRUsername
          PASSWORD: !Ref NRPassword
      Runtime: python3.7
      Timeout: 5
      Layers:
        - "arn:aws:lambda:us-east-1:668099181075:layer:AWSLambda-Python-AWS-SDK:4" # we want a version that has requests built in because packaging stuff is hard.
Parameters:
  Timeout:
    Type: String
    Default: 3600
    Description: Timeout in seconds before reverting an account to basic
  AccountID:
    Type: String
    Description: New Relic account ID. Can be retrived by going to https://one.newrelic.com/launcher/account-settings-launcher.account-settings-launcher and clicking "Users and Roles" then checking the ID in the URL bar
  RoleID:
    Type: String
    Description: The script will only make changes to users that are assigned the role that matches this ID. It can be found by clicking on the role ID in the NR console and checking the URL
  NRUsername:
    Type: String
    Description: Username of the NR account to log into
  NRPassword: 
    Type: String
    Description: Password for the NR account
    NoEcho: true
